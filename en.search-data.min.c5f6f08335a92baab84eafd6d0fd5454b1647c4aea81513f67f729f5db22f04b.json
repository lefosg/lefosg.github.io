[{"id":0,"href":"/posts/llvm.abc/","title":"LLVM AbstractCallSite","section":"Posts","content":"AbstractCallSite is a wrapper around call representations. It provides a unified interface for analysing calls. Generally, it just takes as input the call site, and runs checks on it, no matter what the underlying call instruction is (call, invoke etc.).\nWhat are the possible call representations? Whatever is a CallBase. AbstractCallSite Does not inherit from any class, neither does any class inherit from it.\nWhy would we want to do such a thing? Abstract the call site? Because we want to run optimisations. For example, the Function::hasAddressTaken method uses ACS to check if the name of a function appears in a place other than a direct call. If not, it can inline the function call to gain performance.\nDefinition in llvm/IR/AbstractCallSite.h\nclass AbstractCallSite { private: CallBase *CB; public: LLVM_ABI AbstractCallSite(const Use *U); void getCallbackUses(const CallBase \u0026amp;CB, SmallVectorImpl\u0026lt;const Use *\u0026gt; \u0026amp;CallbackUses); bool isDirectCall(); bool isIndirectCall(); bool isCallbackCall(); bool isCallee(); ... };Generally, to use this class, you construct an object such as AbstractCallSite ACS(\u0026amp;U) as this is the constructor offered by the API. Then, to use the ACS run the check you want, e.g. ACS.isDirectCall() or ACS.isIndirectCall etc.\nNote: Strangely enough, the constructor takes a Use object as parameter and not a Function or a CallBase. It makes sense to pass a Use object to provide context. Remember, we abstract the call site so we can see if ACS.isDirectCall or ACS.isCallbackCall -\u0026gt; we need info about the call site + some function (Use object is perfect for this case).\nIf only a CallBase was provided, we wouldn\u0026rsquo;t know about which function in the argument list we talk about. Or if we only had the Function as a parameter, we may needed to pass an extra argument for the CallBase + even so, the same function may be provided twice as a parameter in a CallBase, so, for which parameter are we talking? So, it makes sense to pass the Use object which provides the User context, and the Value all in one. The constructor makes all necessary sanity checks for the Use object:\nUser of Use must be CallBase or ConstantExpr -\u0026gt; CallBase. Otherwise the ACS is invalid. Value can be anything, it doesn\u0026rsquo;t matter if it is not a function (this leaves some small room for an invalid ACS). If the Value is the Callee -\u0026gt; we have direct/indirect call If the Value is an operand, we have a callback (plus checks some metadata, depends on other optimisations as well) So what the AbstractCallSite does in reality is:\nIs the User of this Use a CallBase? If yes, for the given Value, we can infer if it is a direct/indirect call etc. Finally, it makes sense to use this when iterating over Instructions, and check if something is a CallBase, then abstract it:\nfor (Instruction \u0026amp;I : BB) { if (auto *CB = dyn_cast\u0026lt;CallBase\u0026gt;(\u0026amp;I)) { const Use \u0026amp;CalleeUse = CB-\u0026gt;getCalledOperandUse(); AbstractCallSite ACS(\u0026amp;CalleeUse);Note2: This class defines some terminology. The term broker in the context of callbacks, is the function that takes the callback as parameter, and then calls it in its body. For example:\nvoid my_callback() {} void do_sth(void(*func)(void)) { func();\t} int main() { do_sth(my_callback); }Here do_sth is the broker.\nNote3: Callbacks are a bit of a strange situation. They may not be detected by the AbstractCallSite every time. Because, even though the callback function is located and detected in the parameter list, ACS does not know if it is indeed called in the body of the broker. ACS relies on metadata information emitted by clang (specifically the llvm::MD_callback aka !callback) to classify this Use as callback. For example:\n__attribute__((callback(1))) //I promise arg 1 is a function to be called void functionWithCallback(void (*callback)()) { printf(\u0026#34;Executing callback\\n\u0026#34;); callback(); } __attribute__((callback(1,2))) //Same + the 2nd argument is a paramater of func void functionWithFunctionArg(void (*func)(int), int value) { func(value); } void callbackFunction() { printf(\u0026#34;Callback executed\\n\u0026#34;); } void anotherCallback(int x) { printf(\u0026#34;Another callback: %d\\n\u0026#34;, x); } int main(int argc) { functionWithCallback(callbackFunction); //callback should be detected functionWithFunctionArg(anotherCallback, 200); //same as above }The developer needs to manually add this attribute that says \u0026ldquo;I promise the first argument (clang counts args starting from 1) is a function that will be called\u0026rdquo; and then, provide the indexes of the arguments to be passed like \u0026ldquo;the 1st argument is the function, and if the function takes on argument, the second argument of functionWithFunctionArg is the 1st argument of the callback function func\u0026rdquo; which in reality means 1st_arg(2nd_arg) -\u0026gt; func(value). Clang will then produce the !callback metadata for ACS to consume.\nThis is the ACS code that fails if callback metadata is not found:\nMDNode *CallbackMD = Callee-\u0026gt;getMetadata(LLVMContext::MD_callback); if (!CallbackMD) { NumInvalidAbstractCallSitesNoCallback++; CB = nullptr; return; }"}]